// Copyright (c) 2023 RBB S.r.l
// opensource@mintlayer.org
// SPDX-License-Identifier: MIT
// Licensed under the MIT License;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://github.com/mintlayer/mintlayer-core/blob/master/LICENSE
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

pub mod interactive;
pub mod non_interactive;

use clap::{Command, FromArgMatches, Subcommand};
use rpc::description::{Described, Module};
use tokio::sync::mpsc;
use wallet_rpc_lib::{types::NodeInterface, ColdWalletRpcDescription, WalletRpcDescription};

use crate::{
    cli_event_loop::Event,
    commands::{ColdWalletCommand, ConsoleCommand, WalletCommand},
    errors::WalletCliError,
};

// Strip out usage
const MAIN_HELP_TEMPLATE: &str = "\
    {all-args}
";

// Strip out name/version
const COMMAND_HELP_TEMPLATE: &str = "\
    {about-with-newline}\n\
    {usage-heading}\n    {usage}\n\
    \n\
    {all-args}{after-help}\
";

pub fn get_repl_command(cold_wallet: bool) -> Command {
    const COLD_WALLET_DESC: &Module = &ColdWalletRpcDescription::DESCRIPTION;
    const WALLET_DESC: &Module = &WalletRpcDescription::DESCRIPTION;

    let repl_command = Command::new("repl")
        .multicall(true)
        .arg_required_else_help(true)
        .subcommand_required(true)
        .subcommand_value_name("Command")
        .subcommand_help_heading("Commands")
        .help_template(MAIN_HELP_TEMPLATE);

    // Add commands from generated by clap-derive
    let mut repl_command = if cold_wallet {
        ColdWalletCommand::augment_subcommands(repl_command)
    } else {
        WalletCommand::augment_subcommands(repl_command)
    };

    // Customize the help template for all commands to make it more REPL friendly
    for subcommand in repl_command.get_subcommands_mut() {
        if let Some(desc) =
            COLD_WALLET_DESC.methods.iter().chain(WALLET_DESC.methods).find_map(|method| {
                method
                    .name
                    .split('_')
                    .zip(subcommand.get_name().split('-'))
                    .all(|(x, y)| x == y)
                    .then_some(method.description)
            })
        {
            *subcommand = subcommand.clone().help_template(COMMAND_HELP_TEMPLATE).about(desc);
        } else {
            *subcommand = subcommand.clone().help_template(COMMAND_HELP_TEMPLATE);
        }
    }

    repl_command
}

/// Try to parse REPL input string as a [WalletCommands]
pub fn parse_input<N: NodeInterface>(
    line: &str,
    repl_command: &Command,
) -> Result<Option<WalletCommand>, WalletCliError<N>> {
    let line = line.trim();
    if line.is_empty() || line.starts_with('#') {
        return Ok(None);
    }
    // Split arguments as a normal shell would do
    let args = shlex::split(line).ok_or(WalletCliError::InvalidQuoting)?;
    let mut matches = repl_command
        .clone()
        .try_get_matches_from(args)
        .map_err(WalletCliError::InvalidCommandInput)?;
    let command = WalletCommand::from_arg_matches_mut(&mut matches)
        .map_err(WalletCliError::InvalidCommandInput)?;
    Ok(Some(command))
}

fn run_command_blocking<N: NodeInterface>(
    event_tx: &mpsc::UnboundedSender<Event<N>>,
    command: WalletCommand,
) -> Result<ConsoleCommand, WalletCliError<N>> {
    let (res_tx, res_rx) = tokio::sync::oneshot::channel();
    // channel is closed so exit
    if event_tx.send(Event::HandleCommand { command, res_tx }).is_err() {
        return Ok(ConsoleCommand::Exit);
    }

    res_rx.blocking_recv().expect("Channel must be open")
}
